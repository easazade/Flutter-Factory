# pod_server

This is the starting point for your Serverpod server.

To run your server, you first need to start Postgres and Redis. It's easiest to do with Docker.

    docker compose up --build --detach

Then you can start the Serverpod server.

    dart bin/main.dart

When you are finished, you can shut down Serverpod with `Ctrl-C`, then stop Postgres and Redis.

    docker compose stop

# Access postgres in docker

to connect to postgres databse in docker run
`docker exec -it pod_server-postgres-1 psql -U postgres`

`pod_server-postgres-1` is the postgres container you can get the name from docker agent or running `docker ps` to list containers
`-U` is for the user name of the database you can get these info from `pod_server/config/development.yaml` or `docker-compose.yaml`
Database password is in docker-compose.yaml file

to connect to your database first list Dbs by `\l` then connect to it using `\c` then list tables using `\dt`
then run the command you need. to quit postgres use `\q`.

There is file that is generated by serverpod that conatins command that we should run in `postgres`.
go to `pod_server/generated/tables.pgsql` and copy the command and paste and run them in `postgres`.

---

to change servepod config like ports and stuf you can change it all in `pod_server/config/` folder for
different environments.

# Custom Serializable object

to make a class persistable you should define a model.yaml in protocol. but just to have a class that can be passed as response and request body:

create a `shared` package add it to server & client packages. create serializable models in it. they should
have toJson() and a factory fromJson().
export it in the file you want to be imported by serverpod.

add the file and model as extraClasses in `xxx_server/config/generator.yaml` like below

```yaml
extraClasses:
  - package:shared/shared.dart:Car
```

run `serverpod generate`

# Session

If you need additional information about a call, you may need to cast the Session to one of its subclasses, e.g., `MethodCallSession` or `StreamingSession`. The `MethodCallSession` object provides additional properties, such as the name of the endpoint and method and the underlying HttpRequest object.
example:

```dart
session as MethodCallSession;
var ipAddress = session.httpRequest.remoteIpAddress;
```

# Serverpod Singleton

there is a `Serverpod.instance` that has some nifty functionalities.

for example we can use `createSession` to create one manually (which we are responsible for closing it manually as well).
`session.close()`. If we don't it will cause memory leaks.

# Database

to connect to postgres databse in docker run
`docker exec -it pod_server-postgres-1 psql -U postgres`

protocols define different serializable classes mdoels, exceptions, enums
if we add the table field to the protocol it will generate its database stuff as well. if not it will
only generate a serializable class.

we can define parent child relationship between tables, so when a parent row gets deleted and hence
its children make no more sense to exist, they (children) will be deleted as well.
cehck out user.yaml protocl

complete doc on entities and database => https://docs.serverpod.dev/concepts/database-communication

# Local SMTP server

use mailslurper install it locally. go through the docs in its homepage its very easy to setup and config. make
sure to change the panel port from 8080 to something else.

mail address would be `localhost`
check out pod_server/../server.dart to figure out how to create an instance of `SmtpServer` in dart
to run mailslurper do this. open a terminal, go to directory of mailslurper and then can ./mailslurper
WARNING: just double clicking it didn't work for me.

# Serverpod web server

read webserver and widgets docs. there are pretty cool stuf there
https://docs.serverpod.dev/concepts/webserver
can be used to create web page, custom REST api and webhooks
In addition to the application server, Serverpod comes with a built-in web server. The web server allows you to access your database and business layer the same way you would from a method call from an app. This makes it very easy to share data for applications that need both an app and traditional web pages. You can also use the web server to create webhooks or generate custom REST APIs to communicate with 3rd party services.
